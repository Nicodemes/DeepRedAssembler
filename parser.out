Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    UNKNOWNVALUE

Grammar

Rule 0     S' -> segmentList
Rule 1     segmentList -> segment
Rule 2     segmentList -> segmentList segment
Rule 3     segment -> SEGMENT dataList
Rule 4     dataList -> varassign
Rule 5     dataList -> dataList varassign
Rule 6     varassign -> NAME DECVAR literal
Rule 7     variable -> NAME
Rule 8     statement -> NAME LABLESIGN statement
Rule 9     statement -> OPCODE oprandList
Rule 10    oprandList -> oprand
Rule 11    oprandList -> oprandList oprand
Rule 12    literal -> DEC
Rule 13    literal -> HEX
Rule 14    literal -> BIN
Rule 15    literal -> STRING
Rule 16    oprand -> variable
Rule 17    oprand -> LBRACK literal RBRACK
Rule 18    oprand -> LBRACK variable RBRACK

Terminals, with rules where they appear

BIN                  : 14
COMMENT              : 
DEC                  : 12
DECVAR               : 6
HEX                  : 13
LABLESIGN            : 8
LBRACK               : 17 18
NAME                 : 6 7 8
OPCODE               : 9
RBRACK               : 17 18
SEGMENT              : 3
STRING               : 15
UNKNOWNVALUE         : 
error                : 

Nonterminals, with rules where they appear

dataList             : 3 5
literal              : 6 17
oprand               : 10 11
oprandList           : 9 11
segment              : 1 2
segmentList          : 2 0
statement            : 8
varassign            : 4 5
variable             : 16 18

Parsing method: LALR

state 0

    (0) S' -> . segmentList
    (1) segmentList -> . segment
    (2) segmentList -> . segmentList segment
    (3) segment -> . SEGMENT dataList

    SEGMENT         shift and go to state 2

    segmentList                    shift and go to state 1
    segment                        shift and go to state 3

state 1

    (0) S' -> segmentList .
    (2) segmentList -> segmentList . segment
    (3) segment -> . SEGMENT dataList

    SEGMENT         shift and go to state 2

    segment                        shift and go to state 4

state 2

    (3) segment -> SEGMENT . dataList
    (4) dataList -> . varassign
    (5) dataList -> . dataList varassign
    (6) varassign -> . NAME DECVAR literal

    NAME            shift and go to state 6

    varassign                      shift and go to state 7
    dataList                       shift and go to state 5

state 3

    (1) segmentList -> segment .

    SEGMENT         reduce using rule 1 (segmentList -> segment .)
    $end            reduce using rule 1 (segmentList -> segment .)


state 4

    (2) segmentList -> segmentList segment .

    SEGMENT         reduce using rule 2 (segmentList -> segmentList segment .)
    $end            reduce using rule 2 (segmentList -> segmentList segment .)


state 5

    (3) segment -> SEGMENT dataList .
    (5) dataList -> dataList . varassign
    (6) varassign -> . NAME DECVAR literal

    SEGMENT         reduce using rule 3 (segment -> SEGMENT dataList .)
    $end            reduce using rule 3 (segment -> SEGMENT dataList .)
    NAME            shift and go to state 6

    varassign                      shift and go to state 8

state 6

    (6) varassign -> NAME . DECVAR literal

    DECVAR          shift and go to state 9


state 7

    (4) dataList -> varassign .

    NAME            reduce using rule 4 (dataList -> varassign .)
    SEGMENT         reduce using rule 4 (dataList -> varassign .)
    $end            reduce using rule 4 (dataList -> varassign .)


state 8

    (5) dataList -> dataList varassign .

    NAME            reduce using rule 5 (dataList -> dataList varassign .)
    SEGMENT         reduce using rule 5 (dataList -> dataList varassign .)
    $end            reduce using rule 5 (dataList -> dataList varassign .)


state 9

    (6) varassign -> NAME DECVAR . literal
    (12) literal -> . DEC
    (13) literal -> . HEX
    (14) literal -> . BIN
    (15) literal -> . STRING

    DEC             shift and go to state 14
    HEX             shift and go to state 11
    BIN             shift and go to state 10
    STRING          shift and go to state 12

    literal                        shift and go to state 13

state 10

    (14) literal -> BIN .

    NAME            reduce using rule 14 (literal -> BIN .)
    SEGMENT         reduce using rule 14 (literal -> BIN .)
    $end            reduce using rule 14 (literal -> BIN .)


state 11

    (13) literal -> HEX .

    NAME            reduce using rule 13 (literal -> HEX .)
    SEGMENT         reduce using rule 13 (literal -> HEX .)
    $end            reduce using rule 13 (literal -> HEX .)


state 12

    (15) literal -> STRING .

    NAME            reduce using rule 15 (literal -> STRING .)
    SEGMENT         reduce using rule 15 (literal -> STRING .)
    $end            reduce using rule 15 (literal -> STRING .)


state 13

    (6) varassign -> NAME DECVAR literal .

    NAME            reduce using rule 6 (varassign -> NAME DECVAR literal .)
    SEGMENT         reduce using rule 6 (varassign -> NAME DECVAR literal .)
    $end            reduce using rule 6 (varassign -> NAME DECVAR literal .)


state 14

    (12) literal -> DEC .

    NAME            reduce using rule 12 (literal -> DEC .)
    SEGMENT         reduce using rule 12 (literal -> DEC .)
    $end            reduce using rule 12 (literal -> DEC .)

